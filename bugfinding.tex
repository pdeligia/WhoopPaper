\whoop is a sound but potentially imprecise static data race analyser. In our experience, developers appreciate soundness but do not want to get overwhelmed by countless false positive reports. Towards this we allow an external precise bug-finder to be plugged in the \whoop infrastructure. The race-related information generated by \whoop can then be used to accelerate the bug-finder a bug-finder for concurrent programs that can be easily plugged in our infrastructure. Currently we only support \corral~\cite{lal2012corral}, a state-of-the-art bug-finder used in Microsoft to analyse Windows device drivers. We chose \corral because it is open-source and because it accepts Boogie IVL, similar to \whoop. Our technique, though, should be able to accelerate any arbitrary bug-finder for concurrent programs.

\subsection{Bug-Finding with \corral}
\label{bf:corral}

\corral is a verifier for Boogie IVL that uses SMT solvers (e.g. Z3 or CVC4) underneath to reason about program behaviour and reports a counterexample if an assertion violation is found. \corral attempts to prove reachability of a bug in a goal-directed, lazy fashion to postpone state space explosion when analysing a complex concurrent program. Towards this, \corral performs two abstractions: (i) variable abstraction, where it attempts to identify a minimal set of shared variables that impact the generated verification conditions; and (ii) stratified inlining, where it attempts to identify a minimal unrolling of loops and recursion that also impact the generated verification conditions.

Because \corral performs bounded model checking, it is inherently unsound, in other words it can miss real bugs. Assuming a precise environmental model, though, \corral will only report true bugs. \whoop takes advantage of this precision to report only feasible data races.

\subsection{Sound Partial Order Reduction}
\label{bf:reduction}

By default, \corral instruments a \texttt{yield} statement (which denotes a preemption) before every \emph{visible operation} (i.e. synchronisation operations and shared memory accesses) of a concurrently running thread. It then sequentialises the concurrent program with a schedule that explores all possible interleavings up to a pre-defined bound.

Our idea for accelerating \corral is simple: we simplify the sequentialisation that \corral performs by removing \texttt{yield} statements from all shared memory accesses that \whoop has soundly proved to not be racy. We basically perform a partial order reduction that can significantly reduce the interleavings that \corral needs to explore, and thus increase performance and scalability.

We now show that our partial order reduction is sound, in other words it does not miss any more bugs than the bugs that \corral would miss even without taking advantage of the \whoop race-related information. Let \corral run an $n$ amount of entry point pairs with yields in all visible operations. Let this configuration be known as $C$. Each entry point pair is running in a separate \corral process. \corral will miss all bugs that are triggered by more than 3 bugs running concurrently and all bugs that are triggered by investigating a larger than $r$ recursion bound and larger than $k$ context switch bound. Let \corral then run the same $n$ amount of pairs, but this time with all \texttt{yield} statements in non-racy shared memory accesses (according to \whoop) removed. Let this configuration be known as $W+C$. Because these shared memory accesses cannot race, performing a \texttt{yield} will not introduce any new program behaviours. Thus, \corral will find the same bugs using the configuration $W+C$, as using the configuration $C$.

\subsection{Race Checking Instrumentation}
\label{bf:racechecking}

We use a simple, but effective, race checking instrumentation with \corral. This instrumentation, which is based on previous work~\cite{}, can be enabled using a command line option and we use it as a feasibility checking for the potential data races that \whoop reports. Whenever there is a write access, e.g. \texttt{\$M.13 := 0}, we instrument the Boogie IVL code as follows:

\begin{boogie}
$M.13 := 0;
yield;
assert $M.13 == 0;
\end{boogie}

Likewise, for a read access, e.g. \texttt{\$p0 := \$M.13}, we instrument the Boogie IVL code as follows:

\begin{boogie}
$p0 := $M.13;
yield;
$rv0 := $M.13; // $rv0 is an auxiliary variable
assert $p0 == $rv0;
\end{boogie}

Our instrumentation tolerates benign races, as it will never report a write-write race, if the two write accesses update the shared memory location with the same value.