\whoop is a sound but potentially imprecise static data race analyser.  While
developers do appreciate soundness, it is more important to ensure they are not
overwhelmed by countless reports of false bugs.  Hence, to improve precision, we
enable an external precise bug-finder for concurrent programs to be plugged into
the \whoop infrastructure. The race-related information generated by \whoop can
then be used to accelerate the bug-finder.  Currently, we support
\corral~\cite{lal2012corral}, a state-of-the-art scalable bug-finder used by
Microsoft to analyse Windows device drivers. \corral accepts Boogie IVL and
hence it was easy to integerate into our tool flow. Our technique, though, is
general and capable of accelerating any arbitrary bug-finder for concurrent
programs.

\subsection{Bug-Finding with \corral}
\label{bf:corral}

\corral is a symbolic bounded verifier for Boogie IVL that uses SMT solvers
(e.g., Z3 or CVC4) to statically reason about program behaviours. It checks for
violations of provided assertions, and reports a precise counterexample if an
assertion violation is found. \corral performs bounded exploration of a
concurrent program in two steps. First, given a bound on the number of allowed
context-switches, the concurrent program is appropriately \emph{sequentialized},
and the generated sequential version preserves reachable states of the original
concurrent program~\cite{popl2011-eqr,cav2009-lqr,cavLalR08}.  Then, \corral
attempts to prove bounded (in terms of the number of loop iterations and
recursion depth) sequential reachability of a bug in a goal-directed, lazy
fashion to postpone state space explosion when analysing a large program.  It
performs two abstractions to achieve this: (i) variable abstraction, where it
attempts to identify a minimal set of shared variables that have to be precisely
tracked in order to discharge all assertions; and (ii) stratified inlining,
where it attempts to inline procedures on-demand as they are required for
proving program assertions.


Because \corral performs bounded verification both in terms of the number of
allowed context switches and loop/recursion unrollings, it is inherently
unsound; in other words, it can miss real bugs. On the other hand, \corral is
precise, and assuming a precise model of the program environment it will only
report true bugs. \whoop takes advantage of this precision to report only
feasible data races.

\subsection{Sound Partial Order Reduction}
\label{bf:reduction}

By default, \corral instruments a \texttt{yield} statement (which denotes a
potential nondeterministic context-switch) before each \emph{visible operation}
(i.e., synchronisation operations and shared memory accesses) of every thread.
It then leverages sequentialization to explore all possible thread interleavings
up to a pre-defined bound.

Our approach to accelerating \corral is simple and yet effective: we simplify
the sequentialisation that \corral performs by instrumenting \texttt{yield}
statements only at shared memory accesses that \whoop reported as potentially
racy. This effectively acts as a partial order reduction that can significantly
reduce the number of interleavings that \corral needs to explore, and thus
increase performance and scalability.

\ZRComment{Could this be cleaned up a bit? In particular, do we need to talk
about entry point pairs, or could we prove it just for any pair?}
We now show that our partial order reduction is sound: it does not miss any more
bugs than what \corral would miss even without taking advantage of the \whoop
race-related information. Let \corral run an $n$ amount of entry point pairs
with yields in all visible operations. Let this configuration be known as $C$.
Each entry point pair is running in a separate \corral process. \corral will
miss all bugs that are triggered by more than 3 bugs running concurrently and
all bugs that are triggered by investigating a larger than $r$ recursion bound
and larger than $k$ context switch bound. Let \corral then run the same $n$
amount of pairs, but this time with all \texttt{yield} statements in non-racy
shared memory accesses (according to \whoop) removed. Let this configuration be
known as $W+C$. Because these shared memory accesses cannot race, performing a
\texttt{yield} will not introduce any new program behaviours. Thus, \corral will
find the same bugs using the configuration $W+C$, as using the configuration
$C$.

\subsection{Granularity of Context-Switches}
\label{bf:granularity}

\ZRComment{I think this paragraph is not needed. You already talk about
how \corral by default instruments everything in the beginning of your previous
section. The command line switch /cooperative is I think an implementation
detail we do not have to mention. More generally, I would merge this
subsection with the previous one and I would keep the descriptions of
granularities.}
As aforementioned, \corral instruments by default a \texttt{yield} statement in
each visible operation. Using information from \whoop, though, we can avoid
instrumenting context-switches in memory accesses that do not race. To achieve
this, we use the \corral command line option \texttt{/cooperative}, which
disables \texttt{yield} instrumentation in \corral, and then we instrument
context-switches inside \whoop before sending these Boogie files to \corral. We
have implemented two different levels of context-switch instrumentation
granularity: \emph{\yieldcoarse} and \emph{\yieldmr}.

\yieldcoarse instruments \texttt{yield} statement in a binary fashion: if \whoop
finds that a pair of entry points cannot race, then it will only instrument
context-switches in synchronisation points of this pair; else if \whoop finds
that a pair of entry points can race, then it will instrument context-switches
in all visible operations of this pair.

\yieldmr is a finer-grained instrumentation: \whoop instruments context-switches
in all synchronisation points, but only instruments context-switches in memory
regions that can potentially race (regardless if a pair has not been fully
verified as race-free). In our experiments (see Section~\ref{evaluation}),
\yieldmr performs significantly faster than \yieldcoarse.

\subsection{Race Checking Instrumentation}
\label{bf:racechecking}

We employ a simple, but effective, encoding of data-race checks within \corral.
For example, whenever there is a write access to a shared variable such as
\texttt{\$M.13 := 0}, we instrument the Boogie IVL code to check for write-write
races as follows:
%
\begin{boogie}
$M.13 := 0;        // original write
yield;             // allow for a context-switch
assert $M.13 == 0; // check written value
\end{boogie}
%
Likewise, for a read access to a shared variable such as \texttt{\$p0 :=
\$M.13}, we instrument the Boogie IVL code to check for read-write races as
follows:
\ZRComment{Why do you need this auxiliary variable?}
%
\begin{boogie}
$p0 := $M.13;       // original read
yield;              // allow for a context-switch
$rv0 := $M.13;      // $rv0 is auxiliary variable
assert $p0 == $rv0; // check read value
\end{boogie}

Note that our instrumentation conveniently tolerates most benign races, as it
does not report a write-write race if the two write accesses update the shared
memory location with the same value.  We introduce the instrumentation as a
precise feasibility check for the potential data races that \whoop reports. 

