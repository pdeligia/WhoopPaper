Device drivers exist at the thin boundary between hardware and software. They are complex pieces of system-level software responsible for the interaction between the operating system and any hardware devices that are attached to a computer. Drivers are notoriously hard to develop and even harder to debug~\cite{corbet2005linux}. This has a negative impact in hardware product releases, as time-to-market is commonly dominated by driver development, verification and validation schedules~\cite{yavatkar2012era}.
%
Even after a driver has shipped, it is typically prone to many serious errors: Chou et al.~\cite{chou2001empirical} gathered data from 7 years of Linux kernel releases and found that the relative error-rate in driver source code is up to 10 times higher than in any other part of the kernel; while Swift et al.~\cite{Swift2003windowsxp} found that 85\% of the system crashes in Windows XP are due to faulty drivers. Regarding \emph{concurrency bugs}, a recent study~\cite{ryzhyk2009dingo} found that they account for 19\% of the total bugs in Linux drivers, showcasing their significance. The majority of these concurrency bugs were found to be \emph{data races} or \emph{deadlocks} in various configuration functions and hot-plugging handlers.

A major reason behind these concurrency bugs is that drivers operate inside a complicated and hostile environment~\cite{corbet2005linux}. For example the Linux kernel can invoke its drivers from multiple concurrent threads, a hardware device can issue interrupt requests that cause running processes to block and switch execution context, and the user may decide to remove a device (hot-plugging) while some operation is still running. All these scenarios can easily cause \emph{data races} if no proper synchronization mechanisms (e.g.\ locks) are in place to control concurrent access to shared resources.

Data races are a source of undefined behavior in C, and lead to nondeterministically occurring bugs that can be hard to reproduce, isolate and fix, especially in the context of complex operating systems.
%
Several techniques have been successfully used to analyze device drivers~\cite{ball2006thorough, clarke2004predicate, engler2000checking, henzinger2002temporal, cook2006termination, kuznetsov2010testing, renzelmann2012symdrive, lal2012corral}, but most focus on generic sequential program properties and protocol bugs. Linux kernel analyzers, such as sparse~\cite{corbet2004sparse}, coccinelle~\cite{padioleau2008doc} and lockdep~\cite{corbet2006lock}, can find deadlocks in kernel source code, but are unable to detect races. Techniques that can detect races in drivers~\cite{qadeer2004kiss, pratikakis2006locksmith, voung2007relay, lal2012corral} are usually either \emph{unsound} (i.e.\ can miss real bugs) or \emph{imprecise} (i.e.\ can report false bugs), and typically sacrifice precision for scalability. Thus, there is a clear need for new tools that are able to detect races efficiently and precisely.

In this paper, we present \whoop, a new fully automatic approach that statically analyzes device drivers written in C for data races. \whoop is empowered by \emph{symbolic pairwise lockset analysis}, a novel technique for verifying the absence of data races in device drivers. We attempt to prove a driver race-free by: (i) deriving a sound \emph{sequential} program that \emph{over-approximates} the originally concurrent program; (ii) instrumenting it to record \emph{locksets}; and (iii) using the locksets to assert that all accesses to the same shared resource are \emph{consistently} protected by at least one common lock. Reducing analysis to reasoning over a sequential program avoids the need to enumerate thread interleavings, and allows reuse of existing successful sequential verification techniques.

We then show that by exploiting the race-freedom guarantees provided by our symbolic analysis we can achieve a sound partial-order reduction that significantly accelerates \corral~\cite{lal2012corral}, a state-of-the-art precise bug-finder used by Microsoft to analyze drivers, as well as other concurrent programs. Using \whoop and \corral we analyzed \sizeOfBenchmarks drivers from the 4.0 Linux kernel distribution.  We find that by combining \whoop and \corral we achieve concurrency analysis speedups in the range of 1.5--10$\times$ for most of our benchmarks, compared with using \corral in isolation.  For two drivers, we observe even greater speedups of 12$\times$ and 20$\times$.

\whoop currently supports Linux drivers, but our approach is conceptually generic, thus could be applied to analyze drivers for other operating systems (e.g.\ Windows) as well as other concurrent systems that use a similar programming model (e.g.\ filesystems).

To summarize, our contributions are as follows:
\begin{itemize}
\item We propose symbolic pairwise lockset analysis, a sound and scalable technique for automatically verifying the absence of data races in device drivers.
\item We present \whoop, a tool that leverages our approach for analyzing data races in device drivers.
\item We show that we can achieve a sound partial-order reduction using our technique to accelerate \corral, an industrial-strength bug-finder.
\item We analyze \sizeOfBenchmarks Linux drivers, showing that \whoop is efficient at race-checking and accelerating \corral.
\end{itemize}
