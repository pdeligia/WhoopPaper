Device drivers exist at the thin boundary between hardware and software. They are complex pieces of system-level software responsible for the interaction between an operating system and any hardware devices that are attached to a computer. Device drivers are notoriously hard to develop and even harder to debug~\cite{corbet2005linux}. This has a negative impact in hardware product releases, as time-to-market is commonly dominated by device driver development, verification and validation schedules~\cite{yavatkar2012era}.

Even after a device driver has shipped, it is typically prone to many serious errors: Chou et al.~\cite{chou2001empirical} gathered data from 7 years of Linux kernel releases and found that the relative error-rate in driver source code is up to 10 times higher than in any other part of the kernel; while Swift et al.~\cite{Swift2003windowsxp} found that 85\% of the system crashes in Windows XP are due to faulty drivers. Regarding \emph{concurrency bugs}, a recent study~\cite{ryzhyk2009dingo} found that they account for 19\% of the total bugs in Linux drivers, showcasing their significance. The majority of these concurrency bugs were found to be \emph{data races} or \emph{deadlocks} in various configuration functions and hot-plugging handlers.

A major reason behind these concurrency bugs is that drivers operate inside a complicated and hostile environment~\cite{corbet2005linux}: modern operating systems are able to invoke a device driver from multiple concurrent threads; a hardware device is able to issue interrupt requests that can cause running processes to block and switch execution context; and the user may decide to remove a device while its driver is still running some operation. All these scenarios can easily cause \emph{data races} if no proper synchronisation mechanisms are in place to control concurrent access to shared resources.

Data races lead to nondeterministically occurring bugs that can be hard to reproduce, isolate and debug, especially in the context of a complex operating system. Linux kernel analysers, such as sparse~\cite{corbet2004sparse}, coccinelle~\cite{padioleau2008doc} and lockdep~\cite{corbet2006lock}, have successfully found deadlocks in kernel code, but are typically unable to detect data races. Techniques such as~\cite{ball2006thorough, clarke2004predicate, qadeer2004kiss, engler2000checking, henzinger2002temporal, cook2006termination, pratikakis2006locksmith, kuznetsov2010testing, renzelmann2012symdrive, lal2012corral} have been used to analyse the program behaviour of Linux and Windows device drivers, but primarily focus on finding bugs related to operating system interfacing and/or proving other generic sequential program properties. The few of these techniques that attempt to deal with data races are usually either \emph{unsound} (i.e. can miss real bugs) or \emph{imprecise} (i.e. can report false bugs). Furthermore, most previous techniques that attempt to reason about thread interleavings face significant scalability issues, because of the exponentially large state-space of realistic concurrent programs~\cite{musuvathi2008finding}.

In this paper, we present \emph{static pair-wise lock set analysis}, a novel technique for automatically verifying the absence of data races in device drivers. The key idea behind our approach is that a driver can be proven free from data races by (i) deriving a sound \emph{sequential} model that \emph{over-approximates} the originally concurrent driver, (ii) instrumenting it for lock set analysis and race checking, and (iii) asserting that all accesses to the same shared resource are protected by at least one common lock. The immediate benefit is that our approach not only avoids reasoning about thread interleavings, and thus has the potential to scale well, but also allows the reuse of existing successful sequential verification techniques.

In summary, our paper makes the following two contributions: (i) a novel concurrency verification technique for device drivers based on lock set analysis, sequentialisation and automated theorem proving; and (ii) a prototype tool, \textsc{Whoop}, that implements our technique and can be applied to Linux drivers for automatic concurrency verification.