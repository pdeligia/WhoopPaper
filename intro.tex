Device drivers exist at the thin boundary between hardware and software. They are complex pieces of system-level software responsible for the interaction between an operating system and any hardware devices that are attached to a computer. Device drivers are notoriously hard to develop and even harder to debug~\cite{corbet2005linux}. This has a negative impact in hardware product releases, as time-to-market is commonly dominated by device driver development, verification and validation schedules~\cite{yavatkar2012era}.

Even after a device driver has shipped, it is typically prone to many serious errors: Chou et al.~\cite{chou2001empirical} gathered data from 7 years of Linux kernel releases and found that the relative error-rate in driver source code is up to 10 times higher than in any other part of the kernel; while Swift et al.~\cite{Swift2003windowsxp} found that 85\% of the system crashes in Windows XP are due to faulty drivers. Regarding \emph{concurrency bugs}, a recent study~\cite{ryzhyk2009dingo} found that they account for 19\% of the total bugs in Linux drivers, showcasing their significance. The majority of these concurrency bugs were found to be \emph{data races} or \emph{deadlocks} in various configuration functions and hot-plugging handlers.

A major reason behind these concurrency bugs is that drivers, as well as other kernel modules in general, operate inside a complicated and hostile environment~\cite{corbet2005linux}. For example the Linux kernel is able to invoke its modules from multiple concurrent threads, a hardware device is able to issue interrupt requests that can cause running processes to block and switch execution context, and the user may decide to remove a device while there is still some running operation. All these scenarios can easily cause \emph{data races} if no proper synchronisation mechanisms (such as locks) are in place to control concurrent access to shared resources.

Data races lead to nondeterministically occurring bugs that can be hard to reproduce, isolate and debug, especially in the context of a complex operating system. Linux kernel analysers, such as sparse~\cite{corbet2004sparse}, coccinelle~\cite{padioleau2008doc} and lockdep~\cite{corbet2006lock}, have successfully found deadlocks in kernel code, but are typically unable to detect data races. Techniques such as~\cite{ball2006thorough, clarke2004predicate, qadeer2004kiss, engler2000checking, henzinger2002temporal, cook2006termination, pratikakis2006locksmith, kuznetsov2010testing, renzelmann2012symdrive, lal2012corral} have been used to analyse the program behaviour of Linux and Windows device drivers, but primarily focus on reasoning about generic sequential program properties and finding protocol bugs. The few of these techniques that attempt to deal with data races are usually either \emph{unsound} (i.e. can miss real bugs) or \emph{imprecise} (i.e. can report false bugs). Furthermore, most previous techniques that attempt to reason about thread interleavings face significant scalability issues, because of the exponentially large state-space of realistic concurrent programs~\cite{musuvathi2008finding}.

In this paper, we present \emph{static pairwise lockset analysis}, a novel technique for automatically verifying the absence of data races in Linux kernel modules (e.g. device drivers and filesystems). The key idea behind our approach is that a module can be proven free from data races by (i) deriving a sound \emph{sequential} model that \emph{over-approximates} the originally concurrent program, (ii) instrumenting it for lockset analysis and race checking, and (iii) asserting that all accesses to the same shared resource are protected by at least one common lock. The immediate benefit is that our approach not only avoids reasoning about thread interleavings, and thus has the potential to scale well, but also allows the reuse of existing successful sequential verification techniques. We then show that by exploiting the race-freedom guarantees that our technique provides, we can achieve a sound partial-order reduction and significantly accelerate \corral~\cite{lal2012solver}, a state-of-the-art bug finder that is used by Microsoft to analyse Windows device drivers. We have prototyped this approach in \whoop, a practical tool for automatic concurrency verification, which we used to analyse 10 modules from the Linux distribution.

To summarize, our contributions are as follows:
\begin{itemize}
\item We present static pairwise lockset analysis,  a sound scalable technique for automatically verifying absence of data races in Linux kernel modules.
\item We show that we can achieve a sound partial-order reduction using our technique and significantly accelerate \corral, a state-of-the-art bug finder.
\item We develop \whoop, a prototype tool that implements our approach and we use it to analyse 10 Linux kernel modules.
\end{itemize}