Device drivers exist at the thin boundary between hardware and software. They are complex pieces of system-level software responsible for the interaction between the operating system and any hardware devices that are attached to a computer. Drivers are notoriously hard to develop and even harder to debug~\cite{corbet2005linux}. This has a negative impact in hardware product releases, as time-to-market is commonly dominated by driver development, verification and validation schedules~\cite{yavatkar2012era}.

Even after a driver has shipped, it is typically prone to many serious errors: Chou et al.~\cite{chou2001empirical} gathered data from 7 years of Linux kernel releases and found that the relative error-rate in driver source code is up to 10 times higher than in any other part of the kernel; while Swift et al.~\cite{Swift2003windowsxp} found that 85\% of the system crashes in Windows XP are due to faulty drivers. Regarding \emph{concurrency bugs}, a recent study~\cite{ryzhyk2009dingo} found that they account for 19\% of the total bugs in Linux drivers, showcasing their significance. The majority of these concurrency bugs were found to be \emph{data races} or \emph{deadlocks} in various configuration functions and hot-plugging handlers.

A major reason behind these concurrency bugs is that device drivers operate inside a complicated and hostile environment~\cite{corbet2005linux}. For example the Linux kernel is able to invoke its drivers from multiple concurrent threads, a hardware device is able to issue interrupt requests that can cause running processes to block and switch execution context, and the user may decide to remove a device while there is still some running operation. All these scenarios can easily cause \emph{data races} if no proper synchronization mechanisms (such as locks) are in place to control concurrent access to shared resources.

Data races lead to nondeterministically occurring bugs that can be hard to reproduce, isolate and debug, especially in the context of complex operating systems. Further, according to the C language standard, races result in undefined behavior, which can be the source of tricky compilation and optimization issues (as compilers typically assume race-freedom). Realistic concurrent programs also have an exponentially large state-space, which presents a serious challenge for implementing efficient race-checking techniques~\cite{musuvathi2008finding}.

Techniques such as~\cite{ball2006thorough, clarke2004predicate, engler2000checking, henzinger2002temporal, cook2006termination, kuznetsov2010testing, renzelmann2012symdrive, lal2012corral} have been successfully used to analyze device drivers, but mostly focus on generic sequential program properties and finding protocol bugs. Well-regarded Linux kernel analyzers, such as sparse~\cite{corbet2004sparse}, coccinelle~\cite{padioleau2008doc} and lockdep~\cite{corbet2006lock}, can find deadlocks in kernel source code, but are unable to detect races. Techniques that can detect races in drivers~\cite{qadeer2004kiss, pratikakis2006locksmith, voung2007relay, lal2012corral} are usually either \emph{unsound} (i.e.\ can miss real bugs) or \emph{imprecise} (i.e.\ can report false bugs), and typically sacrifice precision for scalability. Thus, there is a clear need for new tools that are able to detect races efficiently and precisely.

In this paper, we present \whoop, a new fully automatic approach that (i) statically analyzes device drivers written in the C language for data races and (ii) exploits the race-related results from the symbolic analysis to accelerate bug-finding. \whoop is empowered by \emph{symbolic pairwise lockset analysis}, a novel technique for automatically verifying the absence of data races in device drivers. The key idea behind our approach is that a driver can be proven free from data races by (i) deriving a sound \emph{sequential} model that \emph{over-approximates} the originally concurrent program, (ii) instrumenting it for lockset analysis and race-checking, and (iii) asserting that all accesses to the same shared resource are protected by at least one common lock. The immediate benefit is that our approach not only avoids reasoning about thread interleavings, and thus has the potential to scale well, but also allows the reuse of existing successful sequential verification techniques.

We then show that by exploiting the race-freedom guarantees that our symbolic analysis provides, we can achieve a sound partial-order reduction that significantly accelerates \corral~\cite{lal2012corral}, a state-of-the-art bug-finder that is used by Microsoft to analyze device drivers, as well as other concurrent programs. Using \whoop and \corral we analyzed \sizeOfBenchmarks drivers available in the 4.0 Linux kernel distribution.

\whoop currently supports only Linux drivers, but the approach is generic enough and thus we believe that it can be used to analyze drivers from other operating systems (e.g.\ Windows) as well as other concurrent programs with similar structure (e.g.\ filesystems).

To summarize, our contributions are as follows:
\begin{itemize}
\item We present \whoop, a new fully automatic approach for analyzing device drivers for data races and accelerating bug-finding.
\item We discuss symbolic pairwise lockset analysis,  a sound and scalable technique for automatically verifying the absence of data races in device drivers.
\item We show that we can achieve a sound partial-order reduction using our technique and significantly speedup \corral, a state-of-the-art bug-finder.
\item We analyze \sizeOfBenchmarks Linux drivers, showing that \whoop is efficient in race-checking and accelerating \corral.
\end{itemize}
