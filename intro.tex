Device drivers exist at the thin boundary between hardware and software. They are complex pieces of system-level software responsible for the interaction between the operating system and any hardware devices that are attached to a computer. Drivers are notoriously hard to develop and even harder to debug~\cite{corbet2005linux}. This has a negative impact in hardware product releases, as time-to-market is commonly dominated by driver development, verification and validation schedules~\cite{yavatkar2012era}.

Even after a driver has shipped, it is typically prone to many serious errors: Chou et al.~\cite{chou2001empirical} gathered data from 7 years of Linux kernel releases and found that the relative error-rate in driver source code is up to 10 times higher than in any other part of the kernel; while Swift et al.~\cite{Swift2003windowsxp} found that 85\% of the system crashes in Windows XP are due to faulty drivers. Regarding \emph{concurrency bugs}, a recent study~\cite{ryzhyk2009dingo} found that they account for 19\% of the total bugs in Linux drivers, showcasing their significance. The majority of these concurrency bugs were found to be \emph{data races} or \emph{deadlocks} in various configuration functions and hot-plugging handlers.

A major reason behind these concurrency bugs is that device drivers operate inside a complicated and hostile environment~\cite{corbet2005linux}. For example the Linux kernel is able to invoke its drivers from multiple concurrent threads, a hardware device is able to issue interrupt requests that can cause running processes to block and switch execution context, and the user may decide to remove a device while there is still some running operation. All these scenarios can easily cause \emph{data races} if no proper synchronisation mechanisms (such as locks) are in place to control concurrent access to shared resources.

Data races lead to nondeterministically occurring bugs that can be hard to reproduce, isolate and debug, especially in the context of a complex operating system. According to the C language standard, data races also lead to undefined behaviour, which can be the source of various compilation and optimisation issues \PDComment{which is the best cite here?}. Linux kernel analysers, such as sparse~\cite{corbet2004sparse}, coccinelle~\cite{padioleau2008doc} and lockdep~\cite{corbet2006lock}, have successfully found deadlocks in kernel code, but are typically unable to detect data races. Techniques such as~\cite{ball2006thorough, clarke2004predicate, qadeer2004kiss, engler2000checking, henzinger2002temporal, cook2006termination, pratikakis2006locksmith, kuznetsov2010testing, renzelmann2012symdrive, lal2012corral} have been used to analyse the program behaviour of Linux and Windows device drivers, but primarily focus on reasoning about generic sequential program properties and finding protocol bugs. The few of these techniques that attempt to deal with data races are usually either \emph{unsound} (i.e. can miss real bugs) or \emph{imprecise} (i.e. can report false bugs). Furthermore, most previous techniques that attempt to reason about thread interleavings face significant scalability issues, because of the exponentially large state-space of realistic concurrent programs~\cite{musuvathi2008finding}.

In this paper, we present \whoop, a new automatic approach that (i) statically analyses the concurrent behaviour of Linux device drivers written in the C language and (ii) exploits the results from the static analysis to accelerate bug-finding. \whoop is empowered by \emph{static pairwise lockset analysis}, a novel technique for automatically verifying the absence of data races in Linux drivers. The key idea behind our approach is that a driver can be proven free from data races by (i) deriving a sound \emph{sequential} model that \emph{over-approximates} the originally concurrent program, (ii) instrumenting it for lockset analysis and race checking, and (iii) asserting that all accesses to the same shared resource are protected by at least one common lock. The immediate benefit is that our approach not only avoids reasoning about thread interleavings, and thus has the potential to scale well, but also allows the reuse of existing successful sequential verification techniques.

We then show that by exploiting the race-freedom guarantees that our static analysis provides, we can achieve a sound partial-order reduction that significantly accelerates \corral~\cite{lal2012solver}, a state-of-the-art bug-finder that is used by Microsoft to analyse device drivers, as well as other concurrent programs. Using \whoop and \corral we analysed \sizeOfBenchmarks drivers available in the 4.0 Linux kernel distribution.

To summarize, our contributions are as follows:
\begin{itemize}
\item We present \whoop, a practical tool for analysing the concurrent behaviour of Linux drivers and accelerating a plugged-in precise bug-finder.
\item We discuss static pairwise lockset analysis,  a sound scalable technique for automatically verifying absence of data races in Linux drivers.
\item We show that we can achieve a sound partial-order reduction using our technique and significantly accelerate \corral, a state-of-the-art bug-finder.
\item We analyse \sizeOfBenchmarks Linux drivers to show that \whoop is efficient in finding data races.
\end{itemize}