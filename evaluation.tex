\newcommand{\colspacing}{\hspace{1.8em}}
\begin{table}[t]
\small
\centering
\setlength{\tabcolsep}{0.3em}
\caption{Program statistics and race-checking results from applying \whoop and \corral on our benchmarks.}
\label{tab:stats}
\begin{tabular}{l rrr rr r}
\centering
\input{experiments/tables/statistics.tex}
\end{tabular}
\end{table}

\begin{table*}[t]
\small
\centering
\setlength{\tabcolsep}{0.45em}
\caption{Comparison with different yield instrumentation granularities and context-switch bounds.}
\label{tab:results}
\begin{tabular}{l r rrrr rrrr rrrr}
\centering
\input{experiments/tables/scalability.tex}
\end{tabular}
\end{table*}

\begin{figure}
\centering
\includegraphics[width=.99\linewidth]{experiments/figures/yieldmr_vs_yieldall.pdf}
\caption{Scatter plot showing the runtime speedups that \corral achieves using \whoop with the \yieldmr instrumentation. The symbols $+$, $\circ$ and $\times$, represent a context-switch bound of 2, 5 and 9, respectively.}
\label{fig:plot}
\end{figure}

We performed experiments to validate the usefulness of the \whoop approach (\S\ref{whoop}) and its combination with \corral (\S\ref{corral}). We first present race-checking results from running \whoop and \corral on \sizeOfBenchmarks drivers taken from the 4.0 Linux kernel distribution.\footnote{\url{https://www.kernel.org}} We then evaluate the runtime performance and scalability of \corral and \whoop + \corral with different yield instrumentation granularities and context-switch bounds.
Our results demonstrate that \whoop can efficiently accelerate race-checking with \corral.

\medskip\noindent\textbf{Experimental Setup }
%
We performed all experiments on a 3.40GHz Intel Core i7-2600 CPU with 16GB RAM running Ubuntu Linux 12.04.5 LTS, LLVM 3.5, SMACK 1.5, Z3~4.3.2, Boogie rev. 4192 and \corral rev. 534. We also used Mono~4.1.0 to run Boogie and \corral.

\medskip\noindent\textbf{Benchmarks }
%
We evaluate our methodology against \sizeOfBenchmarks drivers taken from the 4.0 Linux kernel. We chose non-trivial drivers from several categories: block; char; ethernet; near field communication (nfc); universal serial bus (usb); and watchdog. We had to manually model the environment for these drivers, a process that required approximately two months of work.

\medskip\noindent\textbf{Race-Checking }
%
Table~\ref{tab:stats} presents statistics for all our benchmarks: lines of code (LoC); number of entry point pairs (\#Pairs); number of SMACK memory regions (\#MRs); number of potentially racy pairs identified by \whoop (\#Racy Pairs); number of potentially racy memory regions reported by \whoop (\#Racy MRs); and number of races discovered by \corral using a context-switch bound of 2 (\#Races Found). We did not discover new races with larger context-switch bounds. This might mean that these drivers only have races that manifest with at least one or two context-switches, or that \corral hit its bounds before discovering a deeper race.

We can see that \whoop reports more races than \corral. This is expected, since \whoop employs an over-approximating shared state abstraction to conservatively model the effects of additional threads when analyzing an entry point pair, and because lockset analysis is inherently imprecise; both factors can lead to false alarm race reports.  On the other hand, \corral is precise, but can miss races because only a limited number of context switches are considered.  Another issue with \corral is loop coverage due to unsound loop unrolling. To tackle this, we enable the built-in loop over-approximation described in~\cite{lal2014powering}. This can potentially lead \corral to report false positives, but we have not seen this in practice. Finally, when we apply \corral to a pair of entry points, we are just checking the specific pair and are not accounting for the effect of other threads (see \S\ref{corral}); this can also cause \corral to miss some races.

Most of the races that \whoop and \corral discovered can be classified in two cases. The first case is accessing a global counter (or flag) from concurrent entry points, without a lock. This might be for performance, and indeed a lot of the races we found might be benign. Even benign races, though, lead to undefined behavior according to the C standard, and it is well known that undefined behaviors can lead to unexpected results when combined with aggressive compiler optimizations. The second case is an entry point accessing a field of an object (either global or passed as a parameter) without a lock. This can lead to a race if another entry point simultaneously accesses the same field of the same object.

As an example of the second case, we found the following race in the generic\_nvram char driver (see Figure~\ref{fig:data_race_example} for the source code): during the \texttt{llseek} entry point, the driver is accessing the file offset \texttt{file->f\_pos} without first acquiring a lock (\texttt{file} is passed as a parameter to \texttt{llseek}). This can lead to a race if the driver invokes \texttt{llseek} from another thread passing the same \texttt{file} object as a parameter. When we investigated another char driver that uses the same APIs, we saw that it was protecting the offset access in its \texttt{llseek} entry point with a mutex. This made us suspicious that the race we found in generic\_nvram could be real. We filed a bug report, but did not manage to get a response yet.

\medskip\noindent\textbf{Granularity of Context-Switches }
%
Table~\ref{tab:results} presents runtime results from using \whoop, \corral and \whoop + \corral to analyze our benchmarks, while Figure~\ref{fig:plot} plots the runtime speedups that \corral achieves using \whoop with the \yieldmr instrumentation. All reported times, in seconds, are averages over three runs. \corral was configured with a time budget of 10 hours (T.O. denotes timeout) and a context-switch bound (csb) of 2, 5 and 9, respectively. For standalone \corral we enable the \yieldall instrumentation, which instruments context-switches (i.e. \texttt{yield} statements) after all visible operations. \whoop + \corral, instead, uses two different context-switch instrumentation granularities, \yieldcoarse and \yieldmr (see \S\ref{corral}). The table also shows the number of context-switches per instrumentation (\#Y).

\whoop uses over-approximation to achieve scalability and, as expected, executes significantly faster than \corral in all our benchmarks. For example, \corral timeouts in all configurations (without and without \whoop) when trying to analyze the r8169 ethernet driver, while \whoop manages to analyze the driver in 144.5 seconds. We believe that the reason behind this is that r8169 has deeply-nested recursion in some entry points, which might get \corral stuck. This is not an issue for \whoop, which uses procedure summarization.

Using the race freedom guarantees that \whoop provides, we managed to significantly accelerate \corral in most of our benchmarks; the best performance was achieved using the \yieldmr instrumentation (see Table~\ref{tab:results}). Figure~\ref{fig:plot} shows that most of our speedups using \yieldmr are in the range of 1.5--10$\times$; whereas in two drivers, ssu100 and pc8736x\_gpio, we achieved $>$10$\times$ and $>$20$\times$ speedups, respectively (with csb of 9). We notice that a higher csb can result into greater speedups, when exploiting \whoop. This is expected, as a higher csb directly translates into a larger sequentialized program.

%When \corral on its own tries to analyze the machzwd watchdog driver it explodes, because in some entry point pairs it attempts to analyze a large number of memory regions. For example for the entry point pair write vs init, it instruments interleavings at 26 different memory regions in a single invocation of \corral, which required approximately 1000 seconds to analyze. The same entry point pair is found race-free by \whoop. Using this information in \corral with the \yieldmr instrumentation, the pair takes less than a second to analyze. The \yieldcoarse instrumentation does not perform as well, because it works in the binary granularity of racy or non-racy entry points.
