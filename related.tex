Statically analyzing concurrent programs to detect races is a promising alternative to dynamic analyzers, which commonly face code coverage issues as they rely on a (controlled) scheduler for exploring execution paths~\cite{musuvathi2008finding}. Warlock~\cite{sterling1993warlock} and LockLint~\cite{oracle2010locklint} are notable examples of static race analyzers. However, both tools have limited applicability, as they heavily rely on user annotations. \textsc{Whoop}, on the other hand, does not require any source code modifications, and thus can be applied with minimal effort.

Most related to our static lockset analysis are the static lockset analyzers RELAY~\cite{voung2007relay} and Locksmith~\cite{pratikakis2006locksmith}. Both tools, though, have significant limitations. The authors of RELAY found 5022 warnings when analyzing the Linux kernel, with only 25 of them being true data races. To limit these false positives, RELAY employs post-analysis unsound filters, but these can also filter out true races. Although Locksmith successfully detected data races in several small Pthreads applications and 7 medium-sized Linux device drivers, it also reported a significant number of false positives. The authors also reported that Locksmith was unable to run on several large programs, showcasing its limited scalability. In contrast, \whoop is based on novel over-approximation techniques and uses modern SMT solvers to accelerate state-of-the-art concurrency bug-finders, such as \corral, for precise \emph{and} scalable analysis.

Our work is not the first to exploit static analysis for achieving efficient race-checking. Prior work includes: \cite{choi2002efficient}, which combined static analysis, optimized instrumentation and runtime access caching to speedup dynamic data race detection; \cite{kahlon2007fast}, which combined a divide-and-conquer strategy that partitions all pointers of a program that cannot alias in disjoint sets and function summarization to achieve a scalable context-sensitive alias analysis for data races; \cite{kahlon2009semantic}, which used abstract interpretation to achieve a sound partial-order reduction on the set of thread interleavings and statically reduce the number of false data race warnings; and \cite{das2015section}, which combined inter-procedural pointer analysis with verifiable user annotations to split programs into disjoint sections, based on non-communicating accesses of shared data, and eliminate redundant checks during dynamic race detection.

Our pairwise approach to analysing driver entry points, employing abstraction to model additional threads, was inspired by the \emph{two thread reduction} used by the GPUVerify tool in the analysis of data-parallel OpenCL and CUDA kernels~\cite{gpuverify,bardsley2014engineering}.  The idea of pairwise analysis of components in a concurrent system has been broadly applied, notably in model checking of cache coherence protocols~\cite{mcmillan1999verification}.
