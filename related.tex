Static race analysis is a promising alternative to dynamic techniques, which restrict analysis to the schedule chosen by a (possibly controlled) scheduler, providing limited coverage~\cite{musuvathi2008finding}. Warlock~\cite{sterling1993warlock} and LockLint~\cite{oracle2010locklint} are notable static race analyzers.  In comparison to \whoop, these tools rely heavily on user annotations.

Most related to our lockset analysis are the static lockset analyzers RELAY~\cite{voung2007relay} and Locksmith~\cite{pratikakis2006locksmith}. Both tools, though, have several limitations. RELAY found 5022 warnings when analyzing the Linux kernel, with only 25 of them being true data races. To tackle this issue, RELAY employs post-analysis unsound filters, but these can also filter out real bugs. Locksmith was successfully applied in several small Pthreads applications and 7 medium-sized Linux device drivers, but the authors reported that the tool was unable to run on several large programs, showcasing its limited scalability. \whoop aims to achieve scalability \emph{and} precision: the first, via novel symbolic pairwise lockset analysis; and the second, by accelerating \corral, an industrial-strength precise bug-finder.

Prior works on static race checking include: \cite{choi2002efficient}, which combines static analysis, optimized instrumentation and runtime access caching to speedup dynamic data race detection; \cite{kahlon2007fast}, which combines a divide-and-conquer strategy that partitions all pointers of a program that cannot alias in disjoint sets and function summarization to achieve a scalable context-sensitive alias analysis for data races; \cite{kahlon2009semantic}, which uses abstract interpretation to achieve a sound partial-order reduction on the set of thread interleavings and statically reduce the number of false data race warnings; and \cite{das2015section}, which combines inter-procedural pointer analysis with verifiable user annotations to split programs into disjoint sections, based on non-communicating accesses of shared data, and eliminate redundant checks during dynamic race detection.

Our pairwise approach to analysing driver entry points, employing abstraction to model additional threads, was inspired by the \emph{two thread reduction} used by the GPUVerify tool in the analysis of data-parallel OpenCL and CUDA kernels~\cite{gpuverify,bardsley2014engineering}.  The idea of pairwise analysis of components in a concurrent system has been broadly applied, notably in model checking of cache coherence protocols~\cite{mcmillan1999verification}.
