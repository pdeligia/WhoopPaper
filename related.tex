Statically analyzing concurrent programs for races is a promising alternative to dynamic analyzers, which typically rely on a (controlled) scheduler for exploring execution paths, and thus can face code coverage issues~\cite{musuvathi2008finding}. Warlock~\cite{sterling1993warlock} and LockLint~\cite{oracle2010locklint} are notable examples of static race analyzers. However, both tools have limited applicability, as they heavily rely on user annotations. \textsc{Whoop}, on the other hand, does not require any source code modifications, and thus can be applied with minimal effort.

Most related to our lockset analysis are the static lockset analyzers RELAY~\cite{voung2007relay} and Locksmith~\cite{pratikakis2006locksmith}. Both tools, though, have several limitations. RELAY found 5022 warnings when analyzing the Linux kernel, with only 25 of them being true data races. To tackle this issue, RELAY employs post-analysis unsound filters, but these can also filter out real bugs. Locksmith was successfully applied in several small Pthreads applications and 7 medium-sized Linux device drivers, but the authors reported that the tool was unable to run on several large programs, showcasing its limited scalability. \whoop aims to achieve scalability \emph{and} precision: the first, via novel symbolic pairwise lockset analysis; and the second, by accelerating \corral, an industrial-strength precise bug-finder.

Our work is not the first to exploit static analysis for achieving efficient race-checking. Prior work includes: \cite{choi2002efficient}, which combined static analysis, optimized instrumentation and runtime access caching to speedup dynamic data race detection; \cite{kahlon2007fast}, which combined a divide-and-conquer strategy that partitions all pointers of a program that cannot alias in disjoint sets and function summarization to achieve a scalable context-sensitive alias analysis for data races; \cite{kahlon2009semantic}, which used abstract interpretation to achieve a sound partial-order reduction on the set of thread interleavings and statically reduce the number of false data race warnings; and \cite{das2015section}, which combined inter-procedural pointer analysis with verifiable user annotations to split programs into disjoint sections, based on non-communicating accesses of shared data, and eliminate redundant checks during dynamic race detection.

Our pairwise approach to analysing driver entry points, employing abstraction to model additional threads, was inspired by the \emph{two thread reduction} used by the GPUVerify tool in the analysis of data-parallel OpenCL and CUDA kernels~\cite{gpuverify,bardsley2014engineering}.  The idea of pairwise analysis of components in a concurrent system has been broadly applied, notably in model checking of cache coherence protocols~\cite{mcmillan1999verification}.
