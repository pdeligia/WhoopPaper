Static race analysis is a promising alternative to dynamic techniques, which restrict analysis to the schedule chosen by a (possibly controlled) scheduler, providing limited coverage~\cite{musuvathi2008finding}. Warlock~\cite{sterling1993warlock} and LockLint~\cite{oracle2010locklint} are notable static race analyzers.  In comparison to \whoop, these tools rely heavily on user annotations.
%
Most related to our lockset analysis are the static lockset analyzers RELAY~\cite{voung2007relay} and Locksmith~\cite{pratikakis2006locksmith}. Both tools, though, have several limitations. RELAY found 5022 warnings when analyzing the Linux kernel, with only 25 of them being true data races. To tackle this issue, RELAY employs unsound post-analysis filters and, hence, can also filter out real bugs. Locksmith was successfully applied in several small Pthreads applications and 7 medium-sized Linux device drivers, but the authors reported that the tool was unable to run on several large programs, hinting at its limited scalability. \whoop aims to achieve scalability \emph{and} precision: the first, via novel symbolic pairwise lockset analysis; and the second, by accelerating \corral, an industrial-strength precise bug-finder.

Prior works on static race checking also include: \cite{choi2002efficient}, which combines static analysis and runtime access caching to speed up dynamic race detection; \cite{kahlon2007fast}, which uses a divide-and-conquer algorithm that partitions all pointers of a program that do not alias in disjoint sets to achieve scalability; \cite{kahlon2009semantic}, which uses abstract interpretation to achieve a sound partial-order reduction on the set of thread interleavings and statically reduce the number of false race warnings; and \cite{das2015section}, which employs inter-procedural alias analysis and verifiable user annotations to split programs into disjoint sections, based on non-communicating accesses of shared data, and eliminate redundant checks during dynamic race detection. Our tool, \whoop, uses symbolic lockset analysis, which involves generating verification conditions and discharging them to a theorem prover, and then uses \corral to filter out false races. 

Our pairwise approach to analysing driver entry points, employing abstraction to model additional threads, was inspired by the \emph{two thread reduction} used by the GPUVerify tool in the analysis of data-parallel OpenCL and CUDA kernels~\cite{gpuverify,bardsley2014engineering}.  The idea of pairwise analysis of components in a concurrent system has been broadly applied, notably in model checking of cache coherence protocols~\cite{mcmillan1999verification}.
