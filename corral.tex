\whoop is a sound but potentially imprecise static data race analyzer.  While developers do appreciate soundness, it is more important to ensure they are not overwhelmed by countless reports of false bugs.  Hence, to improve precision, we enable an external precise bug-finder for concurrent programs to be plugged into \whoop. The race-related information generated by \whoop can then be used to accelerate the bug-finder.  Currently, we support \corral~\cite{lal2012corral, lal2014powering}, a state-of-the-art scalable bug-finder used by Microsoft to analyze Windows device drivers. \corral accepts Boogie IVL and hence it was easy to integrate into our toolchain (see Figure~\ref{fig:whoop} -- C). Our technique, though, is general and capable of accelerating any arbitrary bug-finder for concurrent programs.

\corral is a symbolic bounded verifier for Boogie IVL that uses the Z3 SMT solver to statically reason about program behaviors. It checks for violations of provided assertions, and reports a precise counterexample if an assertion violation is found. \corral performs bounded exploration of a concurrent program in two steps. First, given a bound on the number of allowed context-switches, the concurrent program is appropriately \emph{sequentialized}, and the generated sequential version preserves reachable states of the original concurrent program~\cite{popl2011-eqr,cav2009-lqr,cavLalR08}. Then, \corral attempts to prove bounded (in terms of the number of loop iterations and recursion depth) sequential reachability of a bug in a goal-directed, lazy fashion to postpone state space explosion when analyzing a large program. It performs two abstractions to achieve this: (i) variable abstraction, where it attempts to identify a minimal set of shared variables that have to be precisely tracked in order to discharge all assertions; and (ii) stratified inlining, where it attempts to inline procedures on-demand as they are required for proving program assertions.

Because \corral performs bounded verification both in terms of the number of allowed context-switches and loop/recursion unrollings, it is inherently unsound; in other words, it can miss real bugs. On the other hand, \corral is precise, and assuming a precise model of the program environment it will only report true bugs. \whoop takes advantage of this precision to report only feasible data races.

\medskip\noindent\textbf{Sound Partial-Order Reduction }
%
By default, and assuming no race-freedom guarantees, \whoop instruments a \texttt{yield} statement (which denotes a potential nondeterministic context-switch) after each shared memory access of each entry point.\footnote{In the presence of data races and relaxed memory, even considering all interleavings of shared memory accesses may be insufficient to find all bugs.} \whoop then sends this instrumented program to \corral, which leverages sequentialization to explore all possible thread interleavings up to a pre-defined bound. Our approach to accelerating \corral is simple and yet effective: we simplify the sequentialization that \corral performs by instrumenting \texttt{yield} statements only at shared memory accesses that \whoop reported as potentially racy. This effectively acts as a partial-order reduction that can significantly reduce the number of interleavings that \corral needs to explore, and thus increase performance and scalability.

\ZRComment{Could this be cleaned up a bit? In particular, do we need to talk
about entry point pairs, or could we prove it just for any pair?}

We now show that our partial-order reduction is sound: it does not miss any more bugs than what \corral would miss even without taking advantage of the \whoop race-related information. Let \corral run an $n$ amount of entry point pairs with yields after all \emph{visible} operations (synchronization points and shared memory accesses). Let this configuration be known as $C$. Each entry point pair is running in a separate \corral process. \corral will miss all bugs that are triggered by more than 3 threads running concurrently and all bugs that are triggered by investigating a larger than $r$ recursion bound and larger than $k$ context-switch bound. Let \corral then run the same $n$ amount of pairs, but this time \whoop removes the \texttt{yield} statements after all non-racy shared memory accesses. Let this configuration be known as $W+C$. Because these shared memory accesses cannot race, performing a \texttt{yield} will not introduce any new program behaviors. Thus, \corral will find the same bugs using the configuration $W+C$, as using the configuration $C$.

We have implemented two different levels of context-switch instrumentation granularity:

\yieldcoarse instruments \texttt{yield} statement in a binary fashion: if \whoop
finds that a pair of entry points cannot race, then it will only instrument
context-switches in synchronization points (i.e.\ locks and unlocks) of this pair; else if \whoop finds
that a pair of entry points can race, then it will instrument context-switches
in all visible operations of this pair.

\yieldmr is a finer-grained instrumentation: \whoop instruments context-switches
in all synchronization points, but only instruments context-switches in memory
regions that can potentially race (regardless if a pair has not been fully
verified as race-free). In our experiments (see Section~\ref{evaluation}),
\yieldmr performs significantly faster than \yieldcoarse.

In this work, we use \corral to analyze separate pairs of entry points (as outputted by \whoop), instead of the whole Boogie driver (as outputted by SMACK). We also do not employ any abstraction to model additional threads, as we want \corral to report only true races. Because we only analyze pairs, though, \corral can miss races that require more than two threads to manifest. We argue that this limitation is orthogonal to this work: as long as we compare the same pairs with standalone \corral and with \corral that takes advantage of \whoop, then our comparison is sound. In reality, we could allow \corral to analyze the whole driver, and then instrument \texttt{yield} statements in a coarser granularity (taking into account all threads).

\medskip\noindent\textbf{Race-Checking Instrumentation }
%
In this paper, we treat races as bugs. To detect them, we employ a simple, but effective, encoding of data race checks within \corral. For example, whenever there is a write access to a shared variable $s$, we instrument our abstract Boogie program to check for write-write races as follows:
%
\begin{boogie}
s = e;         // original write
yield;         // allow for a context-switch
assert s == e; // check written value
\end{boogie}
%
Likewise, for a read access to a shared variable $s$, we instrument the abstract Boogie program to check for read-write races as follows:
%
\begin{boogie}
x = s;         // original read
yield;         // allow for a context-switch
assert x == s; // check read value
\end{boogie}

Note that our instrumentation conveniently tolerates most benign races, as it does not report a write-write race if two write accesses update the same shared memory location with the same value.  An advantage of this instrumentation is that it can be used as a precise feasibility check for the potential data races that \whoop reports.
