\ADComment{Top-level questions on this section: do we make it clear how \corral identifies a race?  And do we make it clear enough that although in our experiments we consider accelerating race detection, we can more generally accelerate assertion checking?}

\whoop is a sound but imprecise static data race analyzer.
For developers for whom false alarms are not acceptable, we consider a method for leveraging full or partial
race-freedom guarantees provided by \whoop in order to accelerate the perforance of 
\corral~\cite{lal2012corral}, a precise bug-finding tool.
\corral is used by Microsoft for analysis of Windows device drivers~\cite{lal2014powering},
and has capabilities for analysing concurrent programs.  Because \corral operates on Boogie programs,
it was easy to integrate it into our toolchain (see Figure~\ref{fig:whoop} -- C).
Our technique, though, is general and capable in principle of accelerating any concurrency bug-finder that operates
by interleaving threads at shared memory operations.

\corral is a symbolic bounded verifier for Boogie that uses the Z3 SMT solver to statically reason about program behaviors. It checks for violations of provided assertions, and reports a precise counterexample if an assertion violation is found. \corral performs bounded exploration of a concurrent program in two steps. First, given a bound on the number of allowed context-switches, the concurrent program is appropriately \emph{sequentialized}, and the generated sequential version preserves reachable states of the original concurrent program~\cite{popl2011-eqr,cav2009-lqr,cavLalR08}. Then, \corral attempts to prove bounded (in terms of the number of loop iterations and recursion depth) sequential reachability of a bug in a goal-directed, lazy fashion to postpone state space explosion when analyzing a large program. It uses two key techniques to achieve this: (i) variable abstraction, where it attempts to identify a minimal set of shared variables that have to be precisely tracked in order to discharge all assertions; and (ii) stratified inlining, where it attempts to inline procedures on-demand as they are required for proving program assertions.

Because \corral performs bounded verification both in terms of the number of allowed context-switches and loop/recursion unrollings, it is inherently unsound: it can miss real bugs. On the other hand, \corral is precise, and assuming a precise model of the program environment it will only report true bugs. \whoop takes advantage of this precision to report only feasible data races.

\medskip\noindent\textbf{Sound Partial-Order Reduction }
%
By default, and assuming no race-freedom guarantees, \whoop instruments a \texttt{yield} statement (which denotes a potential nondeterministic context-switch) after each shared memory access of each entry point.\footnote{We acknowledge that in the presence of data races and relaxed memory, even considering all interleavings of shared memory accesses may be insufficient to find all bugs.} \ADComment{We should say here that lock/unlock operations also have yields.} \whoop then sends this instrumented program to \corral, which leverages sequentialization to explore all possible thread interleavings up to a pre-defined bound. Our approach to accelerating \corral is simple and yet effective: we simplify the sequentialization that \corral performs by instrumenting \texttt{yield} statements only at shared memory accesses that \whoop reported as potentially racy. This effectively acts as a partial-order reduction that can significantly reduce the number of interleavings that \corral needs to explore, and thus increase performance and scalability.

We now argue that our partial-order reduction is sound: it does not cause \corral to miss any additional bugs.
\ADComment{Let's go over this together.}
Let \corral run an $n$ amount of entry point pairs with yields after all \emph{visible} operations (synchronization points and shared memory accesses). Let this configuration be known as $C$. Each entry point pair is running in a separate \corral process. \corral will miss all bugs that are triggered by more than 3 threads running concurrently and all bugs that are triggered by investigating a larger than $r$ recursion bound and larger than $k$ context-switch bound. Let \corral then run the same $n$ amount of pairs, but this time \whoop removes the \texttt{yield} statements after all non-racy shared memory accesses. Let this configuration be known as $W+C$. Because these shared memory accesses cannot race, performing a \texttt{yield} will not introduce any new program behaviors. Thus, \corral will find the same bugs using the configuration $W+C$, as using the configuration $C$.

We have implemented two different levels of context-switch instrumentation granularity:

\yieldcoarse instruments \texttt{yield} statement in a binary fashion: if \whoop
finds that a pair of entry points cannot race, then it will only instrument
context-switches in synchronization points (i.e.\ locks and unlocks) of this pair; else if \whoop finds
that a pair of entry points can race, then it will instrument context-switches
in all visible operations of this pair.

\yieldmr is a finer-grained instrumentation: \whoop instruments context-switches
in all synchronization points, but only instruments context-switches in memory
regions that can potentially race (regardless if a pair has not been fully
verified as race-free). In our experiments (see \S\ref{evaluation}),
\yieldmr performs significantly faster than \yieldcoarse.

In this work, we use \corral to analyze individual pairs of entry points.
We do not employ any abstraction to model additional threads, because we want \corral to report only true races. Because we only analyze pairs, though, \corral will miss races that require more than two threads to manifest.
We could extend our setup so that more than two threads are considered by \corral, though because the number of threads that may be launched by an OS kernel is unknown in general, we are inevitably limited by some fixed maximum thread count.

\medskip\noindent\textbf{Race-Checking Instrumentation }
%
In this paper, we treat races as bugs. To detect them, we employ a simple, but effective, encoding of data race checks within \corral. For example, whenever there is a write access to a shared variable $s$, we instrument our abstract Boogie program to check for write-write races as follows:
%
\begin{boogie}
s = e;         // original write
yield;         // allow for a context-switch
assert s == e; // check written value
\end{boogie}
%
Likewise, for a read access to a shared variable $s$, we instrument the abstract Boogie program to check for read-write races as follows:
%
\begin{boogie}
x = s;         // original read
yield;         // allow for a context-switch
assert x == s; // check read value
\end{boogie}

Note that our instrumentation conveniently tolerates most benign races, as it does not report a write-write race if two write accesses update the same shared memory location with the same value.  An advantage of this instrumentation is that it can be used as a precise feasibility check for the potential data races that \whoop reports.
