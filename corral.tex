\whoop is a sound but imprecise static data race analyzer. For developers who deem false alarms as unacceptable, we consider a method for leveraging the full or partial race-freedom guarantees provided by \whoop to accelerate the performance of \corral~\cite{lal2012corral}, a precise bug-finder. \corral, which is used by Microsoft to analyze Windows drivers~\cite{lal2014powering}, has capabilities for analyzing concurrent programs.  Because \corral operates on Boogie programs, it was easy to integrate it into our toolchain (see Figure~\ref{fig:whoop} -- C). Our technique, though, is general and capable in principle of accelerating any concurrency bug-finder that operates by interleaving threads at shared memory operations.

\corral is a symbolic bounded verifier for Boogie IVL that uses the Z3 SMT solver to statically reason about program behaviors. It checks for violations of provided assertions, and reports a precise counterexample if an assertion violation is found. \corral performs bounded exploration of a concurrent program in two steps. First, given a bound on the number of allowed context-switches, the concurrent program is appropriately \emph{sequentialized}, and the generated sequential version preserves reachable states of the original concurrent program~\cite{popl2011-eqr,cav2009-lqr,cavLalR08}. Then, \corral attempts to prove bounded (in terms of the number of loop iterations and recursion depth) sequential reachability of a bug in a goal-directed, lazy fashion to postpone state space explosion when analyzing a large program. It uses two key techniques to achieve this: (i) variable abstraction, where it attempts to identify a minimal set of shared variables that have to be precisely tracked in order to discharge all assertions; and (ii) stratified inlining, where it attempts to inline procedures on-demand as they are required for proving program assertions.

\noindent\textbf{Race-Checking Instrumentation }
%
To detect data races with \corral, \whoop outputs a Boogie program instrumented with a simple, but effective encoding of race checks. Whenever there is a write access to a shared variable $s$, \whoop instruments the program as follows:
%
\begin{boogie}
s = e;         // original write
yield;         // allow for a context-switch
assert s == e; // check written value
\end{boogie}
%
Likewise, whenever there is a read access to $s$, \whoop instruments the program as follows:
%
\begin{boogie}
x = s;         // original read
yield;         // allow for a context-switch
assert x == s; // check read value
\end{boogie}

\corral is inherently unsound (i.e.\ can miss real races), because it performs bounded verification. However, \corral is precise and, assuming a precise environmental model, it will only report true races. \whoop takes advantage of this precision to report only feasible data races.

Note also that our instrumentation conveniently tolerates most benign races, as it does not report a write-write race if two write accesses update the same shared memory location with the same value.

\noindent\textbf{Sound Partial-Order Reduction }
%
By default, and assuming no race-freedom guarantees, \whoop instruments a \texttt{yield} statement (which denotes a potential nondeterministic context-switch) after each shared memory access of each entry point, and after every lock and unlock operation.\footnote{We acknowledge that in the presence of data races and relaxed memory, even considering all interleavings of shared memory accesses may be insufficient to find all bugs.} \whoop then sends this instrumented program to \corral, which leverages sequentialization to explore all possible thread interleavings up to a pre-defined bound. Our approach to accelerating \corral is simple and yet effective: if, thanks to \whoop's analysis, we know that a given statement that accesses shared memory cannot be involved in a data race, we do not instrument a \texttt{yield} after this statement.  This is a form of \emph{partial order reduction}~\cite{DBLP:books/sp/Godefroid96}, and reduces the number of context switches that \corral must consider in a \emph{sound} manner: there is no impact on the bugs that will be detected.  This is because each access for which a \texttt{yield} is suppressed is guaranteed to be protected by some lock (a consequence of lockset analysis).  If the access is a write, its effects are not visible by the other entry point until the lock is released.  If the access is a read, the value of the shared location cannot change until the lock is released.  The fact that a \texttt{yield} is placed after each unlock operation suffices to take account of communication between entry points via the shared memory location.

\ADComment{Don't say ``we regard races as bugs''.  After POR part, emphasize that this idea can be used to accelerate Corral for arbitrary bug-finding in concurrent programs.  Then make it clear that in the remainder of the paper we regard races as bugs and use corral solely to look for races.}

\noindent\textbf{Granularity of Context-Switches }
%
We have implemented two different levels of context-switch instrumentation granularity:

\yieldcoarse instruments \texttt{yield} statement in a binary fashion: if \whoop
finds that a pair of entry points cannot race, then it will only instrument
context-switches in synchronization points (i.e.\ locks and unlocks) of this pair; else if \whoop finds
that a pair of entry points can race, then it will instrument context-switches
in all visible operations of this pair.

\yieldmr is a finer-grained instrumentation: \whoop instruments context-switches
in all synchronization points, but only instruments context-switches in memory
regions that can potentially race (regardless if a pair has not been fully
verified as race-free). In our experiments (see \S\ref{evaluation}),
\yieldmr performs significantly faster than \yieldcoarse.

In this work, we use \corral to analyze individual pairs of entry points.
We do not employ any abstraction to model additional threads, because we want \corral to report only true races. Because we only analyze pairs, though, \corral will miss races that require more than two threads to manifest.
We could extend our setup so that more than two threads are considered by \corral, though because the number of threads that may be launched by an OS kernel is unknown in general, we are inevitably limited by some fixed maximum thread count.
