\whoop is a sound but potentially imprecise static data race analyzer.  While developers do appreciate soundness, it is more important to ensure they are not overwhelmed by countless reports of false bugs.  Hence, to improve precision, we enable an external precise bug-finder for concurrent programs to be plugged into \whoop. The race-related information generated by \whoop can then be used to accelerate the bug-finder.  Currently, we support \corral~\cite{lal2012corral, lal2014powering}, a state-of-the-art scalable bug-finder used by Microsoft to analyze Windows device drivers. \corral accepts Boogie IVL and hence it was easy to integrate into our toolchain (see Figure~\ref{fig:whoop} -- C). Our technique, though, is general and capable of accelerating any arbitrary bug-finder for concurrent programs.

\corral is a symbolic bounded verifier for Boogie IVL that uses the Z3 SMT solver to statically reason about program behaviors. It checks for violations of provided assertions, and reports a precise counterexample if an assertion violation is found. \corral performs bounded exploration of a concurrent program in two steps. First, given a bound on the number of allowed context-switches, the concurrent program is appropriately \emph{sequentialized}, and the generated sequential version preserves reachable states of the original concurrent program~\cite{popl2011-eqr,cav2009-lqr,cavLalR08}. Then, \corral attempts to prove bounded (in terms of the number of loop iterations and recursion depth) sequential reachability of a bug in a goal-directed, lazy fashion to postpone state space explosion when analyzing a large program. It performs two abstractions to achieve this: (i) variable abstraction, where it attempts to identify a minimal set of shared variables that have to be precisely tracked in order to discharge all assertions; and (ii) stratified inlining, where it attempts to inline procedures on-demand as they are required for proving program assertions.

Because \corral performs bounded verification both in terms of the number of allowed context-switches and loop/recursion unrollings, it is inherently unsound; in other words, it can miss real bugs. On the other hand, \corral is precise, and assuming a precise model of the program environment it will only report true bugs. \whoop takes advantage of this precision to report only feasible data races.

\noindent
\textbf{Sound Partial-Order Reduction}\xspace\xspace By default, \corral instruments a \texttt{yield} statement (which denotes a potential nondeterministic context-switch) before each \emph{visible operation} (i.e., synchronization operations and shared memory accesses) of every thread. It then leverages sequentialization to explore all possible thread interleavings up to a pre-defined bound.

Our approach to accelerating \corral is simple and yet effective: we simplify
the sequentialization that \corral performs by instrumenting \texttt{yield}
statements only at shared memory accesses that \whoop reported as potentially
racy.\footnote{In the presence of data races and relaxed memory, even considering all interleavings of shared memory accesses may be insufficient to find all bugs.} This effectively acts as a partial-order reduction that can significantly
reduce the number of interleavings that \corral needs to explore, and thus
increase performance and scalability.

\ZRComment{Could this be cleaned up a bit? In particular, do we need to talk
about entry point pairs, or could we prove it just for any pair?}\PDComment{Lets also see what Ally thinks about this part.}
We now show that our partial-order reduction is sound: it does not miss any more
bugs than what \corral would miss even without taking advantage of the \whoop
race-related information. Let \corral run an $n$ amount of entry point pairs
with yields in all visible operations. Let this configuration be known as $C$.
Each entry point pair is running in a separate \corral process. \corral will
miss all bugs that are triggered by more than 3 bugs running concurrently and
all bugs that are triggered by investigating a larger than $r$ recursion bound
and larger than $k$ context-switch bound. Let \corral then run the same $n$
amount of pairs, but this time with all \texttt{yield} statements in non-racy
shared memory accesses that are removed according to information from \whoop. Let this configuration be
known as $W+C$. Because these shared memory accesses cannot race, performing a
\texttt{yield} will not introduce any new program behaviors. Thus, \corral will
find the same bugs using the configuration $W+C$, as using the configuration
$C$.

We have implemented two different levels of context-switch instrumentation granularity:

\yieldcoarse instruments \texttt{yield} statement in a binary fashion: if \whoop
finds that a pair of entry points cannot race, then it will only instrument
context-switches in synchronization points of this pair; else if \whoop finds
that a pair of entry points can race, then it will instrument context-switches
in all visible operations of this pair.

\yieldmr is a finer-grained instrumentation: \whoop instruments context-switches
in all synchronization points, but only instruments context-switches in memory
regions that can potentially race (regardless if a pair has not been fully
verified as race-free). In our experiments (see Section~\ref{evaluation}),
\yieldmr performs significantly faster than \yieldcoarse.

\noindent
\textbf{Race-Checking Instrumentation}\xspace\xspace In this paper, we treat races as bugs. To detect them, we employ a simple, but effective, encoding of data race checks within \corral.
For example, whenever there is a write access to a shared variable, such as
\texttt{\$M.13 := 0}, we instrument the Boogie IVL code to check for write-write
races as follows:
%
\begin{boogie}
$M.13 := 0;        // original write
yield;             // allow for a context-switch
assert $M.13 == 0; // check written value
\end{boogie}
%
Likewise, for a read access to a shared variable, such as \texttt{\$p0 :=
\$M.13}, we instrument the Boogie IVL code to check for read-write races as
follows:
%
\begin{boogie}
$p0 := $M.13;        // original read
yield;               // allow for a context-switch
assert $p0 == $M.13; // check read value
\end{boogie}

Note that our instrumentation conveniently tolerates most benign races, as it does not report a write-write race if two write accesses update the same shared memory location with the same value.  An advantage of this instrumentation is that it can be used as a precise feasibility check for the potential data races that \whoop reports.
